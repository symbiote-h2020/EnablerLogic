buildscript {
    ext {
        springBootVersion = '1.5.14.RELEASE'
        springCloudVersion = 'Dalston.SR5'
    }
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
        classpath group: 'com.cinnober.gradle', name: 'semver-git', version: '2.3.1'
    }
}

plugins {
    id 'java'
    id 'io.franzbecker.gradle-lombok' version '1.8'

    // code quality
    id "jacoco"

    // IDEs
    id "eclipse"
    id "idea"
    
    // publishing
    id "maven"
    id "maven-publish"
}

apply plugin: 'org.springframework.boot'
apply plugin: 'com.cinnober.gradle.semver-git'

group = 'eu.h2020.symbiote'

// this is needed for starter to not create fat jar
bootRepackage.enabled = false

eclipse {
    classpath {
        downloadJavadoc = true
        downloadSources = true
    }
}

// adding sources for integrationTests
sourceSets {
    integrationTest {
        java {
            compileClasspath += main.output + test.output
            runtimeClasspath += main.output + test.output
            srcDir file('src/integration-test/java')
        }
        resources.srcDir file('src/integration-test/resources')
    }
}

configurations {
    integrationTestCompile.extendsFrom testCompile
    integrationTestRuntime.extendsFrom testRuntime
}


allprojects {
    repositories {
	    mavenLocal()
        jcenter()
        maven { url "https://jitpack.io" }
    }
}

sourceCompatibility = 1.8
targetCompatibility = 1.8

configurations.all {
    // check for updates every build
    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
}


dependencies {
    compile('org.springframework.boot:spring-boot-starter')
    compile('org.springframework.cloud:spring-cloud-starter-config')
    compile('org.springframework.cloud:spring-cloud-starter-eureka')
    compile('org.springframework.cloud:spring-cloud-starter-zipkin') // Causes the java.net.ConnectException if Zipkin offline
    compile('org.springframework.cloud:spring-cloud-starter-feign')
    compile('org.springframework.boot:spring-boot-starter-amqp')
    compile('org.springframework.boot:spring-boot-starter-data-rest')

    compile('com.github.symbiote-h2020:SymbIoTeLibraries:5.32+') { changing = true }
	
	// from jitpack
	compile('com.github.symbiote-h2020:ResourceAccessProxyPluginStarter:0.3+')
	// from local maven
    //compile('eu.h2020.symbiote:ResourceAccessProxyPlugin:0.1.0-SNAPSHOT')
    
    compileOnly('org.projectlombok:lombok')

    testCompile('org.springframework.boot:spring-boot-starter-test')
	testCompile('org.assertj:assertj-core:3.10.0')
    testCompile('org.awaitility:awaitility:3.1.0')
    testCompile('com.revinate:assertj-json:1.0.1')
    testCompile('io.arivera.oss:embedded-rabbitmq:1.1.2')
    testCompile('org.springframework.cloud:spring-cloud-contract-wiremock')
    // for some exporatory tests 
    //testCompile('com.github.symbiote-h2020:SMEURLibraries:develop-SNAPSHOT')
    
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
    }
}

jar {
    //baseName = rootProject.name
    version =  project.version
}

// creating source jar
task sourceJar(type: Jar) {
    from sourceSets.main.allJava
    //baseName = rootProject.name
    //version =  project.version
    
}

task generateJavaDocs(type: Javadoc) {
    source = sourceSets.main.allJava
    classpath = project.sourceSets.main.compileClasspath 
    destinationDir = reporting.file("javadocs")
}

task javadocJar(type: Jar, dependsOn: generateJavaDocs) {
    classifier = 'javadoc'
    from javadoc.destinationDir
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            groupId = project.group
            version = project.version
            from components.java
            
            artifact sourceJar {
                classifier "sources"
            }

            artifact javadocJar
        }
    }
}

configurations.all {
    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
}

// jacoco configuration section
jacoco {
    toolVersion = "0.8.1"
}

jacocoTestReport {
    reports {
        xml.enabled = true
        html.enabled = true
    }
}

// including code quality extensions into the build
check.dependsOn(jacocoTestReport)

// integration tests
task integrationTest(type: Test) {
    jacoco {
      destinationFile = file("$buildDir/jacoco/integrationTest.exec")
      classDumpDir = file("$buildDir/build/classes/main")
   }

    testClassesDir = sourceSets.integrationTest.output.classesDir
    classpath = sourceSets.integrationTest.runtimeClasspath
    outputs.upToDateWhen { false }
}

check.dependsOn integrationTest
integrationTest.mustRunAfter test

task allTestReport(type: TestReport) {
    destinationDir = file("$buildDir/reports/allTests")
}

test {
    jacoco {
        destinationFile = file("$buildDir/jacoco/test.exec")
        classDumpDir = file("$buildDir/build/classes/main")
    }
}

// integration test reporting
task jacocoIntegrationTestReport(type: JacocoReport) {
    group = "Reporting"
    description = "Generate Jacoco integration test coverage reports"
 
    reports {
        xml.enabled = true
        xml.destination = file("${buildDir}/reports/jacoco/integrationTest/jacocoIntegrationTest.xml")
        html.enabled = true
        html.destination = file("${buildDir}/reports/jacoco/integrationTest/html")
    }
 
 	executionData integrationTest
 	sourceSets sourceSets.main
}

jacocoIntegrationTestReport.dependsOn integrationTest
check.dependsOn jacocoIntegrationTestReport

// all tests reporting
task jacocoAllTestReport(type: JacocoReport) {
    group = "Reporting"
    description = "Generate Jacoco all test coverage reports"
 
    reports {
        xml.enabled = true
        xml.destination = file("${buildDir}/reports/jacoco/allTest/jacocoAllTest.xml")
        html.enabled = true
        html.destination = file("${buildDir}/reports/jacoco/allTest/html")
    }
 
 	executionData test, integrationTest
 	sourceSets sourceSets.main
}
jacocoAllTestReport.dependsOn test, integrationTest
check.dependsOn jacocoAllTestReport

// reports for integration tests in different directory
tasks.withType(Test) {
    reports.html.destination = file("${reporting.baseDir}/${name}")
}


/*
Run only unit tests
 > gradle clean test

Run only integration tests
> gradle clean integrationTest

Run all tests
> gradle clean test integrationTest

Run build with all tests
>  gradle clean build

Run build and exclude integration tests
> gradle clean build -x integrationTest

publishing starter to mavenLocal
> gradle clean build publishToMavenLocal
*/
